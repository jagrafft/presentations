## Approach
- Identify set of items/issues/problems/...
    - SMALL NUMBER!! -> 3?
- Investigate [Julia, Python] -> item_performance(_) language-specifically
- Make comparisons from here

## Avoid
- Language *Y* includes feature *X* in base/core/... comparisons
    - Okay to mention as needed/true. **NOT** a metric.
- "The Russell"
    - Philosophy can be commented to (e.g. "Guido's tail recursion"), but arguments remain strictly technical. (e.g. In this case you must show that tail recursion is superior.)

## Knowns
- Julia v0.7.x
- Python v3.7.x
- Exploration of how each language handles a set of problems

## Production
- Code examples
    - Scripts and REPL? (preferred)
    - Notebook(s)?
- Slides with Pandoc
    - https://github.com/jgm/pandoc/wiki/Using-pandoc-to-produce-reveal.js-slides

## Possible References
- [Erlang's Tail Recursion is Not a Silver Bullet](https://ferd.ca/erlang-s-tail-recursion-is-not-a-silver-bullet.html)
- [Julia Docs](https://docs.julialang.org/)
- [The Seven Myths of Erlang Performance](http://erlang.org/doc/efficiency_guide/myths.html)
    - *2.1 Myth: Tail-Recursive Functions are Much Faster Than Recursive Functions*